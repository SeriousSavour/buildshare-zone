<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- CRITICAL: Security must load FIRST before any other scripts -->
    <script>
      (function() {
        'use strict';
        
        const currentOrigin = window.location.origin;
        const allowedDomains = ['localhost', '127.0.0.1', 'lovable.app'];
        
        // Freeze critical objects to prevent extension manipulation
        const originalDefineProperty = Object.defineProperty;
        const originalFreeze = Object.freeze;
        
        // Store original methods before extensions can modify them
        const originalOpen = window.open;
        const originalAssign = window.location.assign;
        const originalReplace = window.location.replace;
        
        // Create immutable protection
        let protectedHref = window.location.href;
        let redirectBlocked = false;
        
        // Override location.href with getter/setter that can't be overridden
        originalDefineProperty(window.location, 'href', {
          get: function() { return protectedHref; },
          set: function(url) {
            if (!url.startsWith(currentOrigin) && !url.startsWith('/') && !url.startsWith('#')) {
              console.error('üõ°Ô∏è BLOCKED redirect to:', url);
              redirectBlocked = true;
              alert('Security: Unauthorized redirect blocked');
              return protectedHref;
            }
            protectedHref = url;
            originalAssign.call(window.location, url);
          },
          configurable: false,
          enumerable: true
        });
        
        // Override window.open
        window.open = function(url, target, features) {
          if (url && !url.startsWith(currentOrigin) && !url.startsWith('/') && !url.startsWith('#')) {
            console.error('üõ°Ô∏è BLOCKED window.open to:', url);
            alert('Security: Unauthorized popup blocked');
            return null;
          }
          return originalOpen.call(window, url, target, features);
        };
        
        // Override location.assign
        window.location.assign = function(url) {
          if (!url.startsWith(currentOrigin) && !url.startsWith('/') && !url.startsWith('#')) {
            console.error('üõ°Ô∏è BLOCKED location.assign to:', url);
            alert('Security: Unauthorized navigation blocked');
            return;
          }
          return originalAssign.call(window.location, url);
        };
        
        // Override location.replace
        window.location.replace = function(url) {
          if (!url.startsWith(currentOrigin) && !url.startsWith('/') && !url.startsWith('#')) {
            console.error('üõ°Ô∏è BLOCKED location.replace to:', url);
            alert('Security: Unauthorized navigation blocked');
            return;
          }
          return originalReplace.call(window.location, url);
        };
        
        // Freeze these functions so extensions can't re-override them
        originalFreeze(window.open);
        originalFreeze(window.location.assign);
        originalFreeze(window.location.replace);
        
        // Prevent history manipulation
        const originalPushState = history.pushState;
        const originalReplaceState = history.replaceState;
        
        history.pushState = function(state, title, url) {
          if (url && !url.startsWith(currentOrigin) && !url.startsWith('/') && !url.startsWith('#')) {
            console.error('üõ°Ô∏è BLOCKED history.pushState to:', url);
            return;
          }
          return originalPushState.apply(history, arguments);
        };
        
        history.replaceState = function(state, title, url) {
          if (url && !url.startsWith(currentOrigin) && !url.startsWith('/') && !url.startsWith('#')) {
            console.error('üõ°Ô∏è BLOCKED history.replaceState to:', url);
            return;
          }
          return originalReplaceState.apply(history, arguments);
        };
        
        // Monitor for navigation attempts
        window.addEventListener('beforeunload', function(e) {
          const newUrl = window.location.href;
          if (redirectBlocked || (newUrl !== protectedHref && !newUrl.startsWith(currentOrigin))) {
            e.preventDefault();
            e.returnValue = '';
            console.error('üõ°Ô∏è BLOCKED navigation attempt');
            return '';
          }
        }, true);
        
        // Detect extension script injection
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
              if (node.nodeName === 'SCRIPT' && node.src && !node.src.includes(currentOrigin)) {
                console.warn('üõ°Ô∏è Extension script detected:', node.src);
                // Don't remove, just log - removing might break legitimate extensions
              }
            });
          });
        });
        
        observer.observe(document.documentElement, { childList: true, subtree: true });
        
        console.log('üõ°Ô∏è Enhanced security protection active');
        
        // Register Service Worker for network-level protection
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', function() {
            navigator.serviceWorker.register('/security-sw.js')
              .then(function(registration) {
                console.log('üõ°Ô∏è Security SW registered:', registration.scope);
                
                // Listen for messages from Service Worker
                navigator.serviceWorker.addEventListener('message', function(event) {
                  if (event.data.type === 'REDIRECT_BLOCKED') {
                    console.error('üõ°Ô∏è Service Worker blocked redirect to:', event.data.blockedUrl);
                    alert('Security: Malicious redirect blocked by Service Worker');
                  }
                });
              })
              .catch(function(error) {
                console.warn('üõ°Ô∏è Security SW registration failed:', error);
              });
          });
        }
      })();
    </script>
    
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Learning Hub - Educational Tools & Interactive Apps</title>
    <meta name="description" content="Discover educational tools, productivity apps, and interactive learning experiences. Safe, moderated platform for students and professionals.">
    <meta name="author" content="Lovable" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Roboto:wght@300;400;500;700&family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@400;500;600;700;800&family=Merriweather:wght@300;400;700&family=JetBrains+Mono:wght@300;400;500;600;700;800&family=Space+Grotesk:wght@300;400;500;600;700&family=Lobster&family=Mountains+of+Christmas:wght@400;700&family=Special+Elite&display=swap" rel="stylesheet">

    <!-- Enhanced Security Headers -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; worker-src 'self' blob:; connect-src 'self' https://cdn.jsdelivr.net https://ptmeykacgbrsmvcvwrpp.supabase.co wss://ptmeykacgbrsmvcvwrpp.supabase.co; style-src 'self' 'unsafe-inline'; style-src-elem 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: blob: https:; frame-src 'self' https:; frame-ancestors 'none'; upgrade-insecure-requests;">
    <meta name="referrer" content="strict-origin-when-cross-origin">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=()">


    <meta property="og:title" content="Learning Hub - Educational Platform" />
    <meta property="og:description" content="Educational tools and interactive apps for learning and productivity" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://storage.googleapis.com/gpt-engineer-file-uploads/WNETjOaKhfZppplLvocUv9JuKrz2/social-images/social-1758071962505-download (4).jfif">

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@lovable_dev" />
    <meta name="twitter:image" content="https://storage.googleapis.com/gpt-engineer-file-uploads/WNETjOaKhfZppplLvocUv9JuKrz2/social-images/social-1758071962505-download (4).jfif">
    <link rel="icon" type="image/x-icon" href="https://storage.googleapis.com/gpt-engineer-file-uploads/WNETjOaKhfZppplLvocUv9JuKrz2/uploads/1758071967714-download (5).jfif">
</head>

  <body>
    <div id="root"></div>
    
    <script type="module" src="/src/main.tsx"></script>
    
    <!-- Anti-embedding protection -->
    <script>
      // Prevent iframe embedding
      if (window.top !== window.self) {
        window.top.location = window.self.location;
      }
      
      // Block outgoing redirects from malicious scripts/extensions
      const originalWindowOpen = window.open;
      const originalLocationAssign = window.location.assign;
      const originalLocationReplace = window.location.replace;
      const currentOrigin = window.location.origin;
      
      // Override window.open
      window.open = function(url, target, features) {
        if (url && !url.startsWith(currentOrigin) && !url.startsWith('/')) {
          console.warn('Blocked unauthorized window.open to:', url);
          return null;
        }
        return originalWindowOpen.call(window, url, target, features);
      };
      
      // Override location.assign
      window.location.assign = function(url) {
        if (!url.startsWith(currentOrigin) && !url.startsWith('/')) {
          console.warn('Blocked unauthorized location.assign to:', url);
          return;
        }
        return originalLocationAssign.call(window.location, url);
      };
      
      // Override location.replace
      window.location.replace = function(url) {
        if (!url.startsWith(currentOrigin) && !url.startsWith('/')) {
          console.warn('Blocked unauthorized location.replace to:', url);
          return;
        }
        return originalLocationReplace.call(window.location, url);
      };
      
      // Monitor location.href changes
      let lastHref = window.location.href;
      Object.defineProperty(window.location, 'href', {
        get: function() {
          return lastHref;
        },
        set: function(url) {
          if (!url.startsWith(currentOrigin) && !url.startsWith('/')) {
            console.warn('Blocked unauthorized location.href change to:', url);
            return lastHref;
          }
          lastHref = url;
          window.location.assign(url);
        }
      });
      
      // Enhanced referrer protection with blocking
      const allowedDomains = [
        'localhost',
        '127.0.0.1',
        'lovable.app',
        window.location.hostname // Always allow current domain
      ];
      
      if (document.referrer) {
        try {
          const referrerHost = new URL(document.referrer).hostname;
          const currentHost = window.location.hostname;
          
          // Check if referrer is unauthorized
          if (referrerHost !== currentHost && !allowedDomains.some(domain => 
            referrerHost.includes(domain) || currentHost.includes(domain)
          )) {
            // Block access and redirect to home
            console.warn('Unauthorized referrer detected:', referrerHost);
            document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;font-family:sans-serif;"><h1>Access Denied</h1></div>';
            setTimeout(() => {
              window.location.href = window.location.origin;
            }, 1000);
          }
        } catch (e) {
          // If referrer parsing fails, allow access
          console.log('Referrer check bypassed');
        }
      }
      
      // Disable right-click context menu (basic protection)
      document.addEventListener('contextmenu', function(e) {
        e.preventDefault();
      });
      
      // Disable common keyboard shortcuts for viewing source
      document.addEventListener('keydown', function(e) {
        if (e.key === 'F12' || 
            (e.ctrlKey && e.shiftKey && e.key === 'I') ||
            (e.ctrlKey && e.shiftKey && e.key === 'C') ||
            (e.ctrlKey && e.key === 'U')) {
          e.preventDefault();
        }
      });
      
      // Monitor DOM mutations for malicious script injections
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.addedNodes.forEach((node) => {
            // Check for suspicious script injections
            if (node.nodeName === 'SCRIPT') {
              const src = node.src || '';
              const currentDomain = window.location.hostname;
              
              // Block scripts from unknown sources
              if (src && !src.includes(currentDomain) && 
                  !src.includes('lovable.app') && 
                  !src.includes('cdn.jsdelivr.net')) {
                console.warn('Blocked suspicious script injection:', src);
                node.remove();
              }
            }
            
            // Check for suspicious iframe injections
            if (node.nodeName === 'IFRAME') {
              const src = node.src || '';
              const id = node.id || '';
              
              // Allow only app-controlled iframes
              if (!id.startsWith('game-iframe-') && !id.startsWith('app-')) {
                console.warn('Blocked unauthorized iframe injection:', src);
                node.remove();
              }
            }
          });
        });
      });
      
      // Start observing document for DOM changes
      observer.observe(document.documentElement, {
        childList: true,
        subtree: true
      });
      
      // Block fetch/XMLHttpRequest to suspicious domains
      const originalFetch = window.fetch;
      window.fetch = function(url, options) {
        const urlStr = typeof url === 'string' ? url : url.toString();
        
        // Allow internal and whitelisted domains
        if (urlStr.startsWith('/') || 
            urlStr.includes(window.location.hostname) ||
            urlStr.includes('supabase.co') ||
            urlStr.includes('cdn.jsdelivr.net')) {
          return originalFetch.apply(this, arguments);
        }
        
        // Log and allow but monitor other domains
        console.log('External fetch detected:', urlStr);
        return originalFetch.apply(this, arguments);
      };
      
      // Detect extension manipulation attempts
      let extensionDetected = false;
      const checkForExtensions = () => {
        // Check for common extension manipulation patterns
        const suspiciousGlobals = [
          '__REACT_DEVTOOLS_GLOBAL_HOOK__',
          'chrome.webRequest',
          'chrome.declarativeNetRequest'
        ];
        
        suspiciousGlobals.forEach(key => {
          if (window[key] && !extensionDetected) {
            console.log('Browser extension detected:', key);
            extensionDetected = true;
          }
        });
      };
      
      // Run extension check
      setTimeout(checkForExtensions, 1000);
    </script>
  </body>
</html>
